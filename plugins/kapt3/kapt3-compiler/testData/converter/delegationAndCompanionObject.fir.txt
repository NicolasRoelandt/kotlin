/**
 * public abstract interface A : kotlin/Any {
 *
 *   // signature: inject(LA$B;)V
 *   public abstract fun inject(b: A.B): kotlin/Unit
 *
 *   // getter: getX()Ljava/lang/String;
 *   public abstract val x: kotlin/String
 *     public abstract get
 *
 *   // companion object: Companion
 *
 *   // nested class: Companion
 *
 *   // nested class: B
 *
 *   // module name: main
 * }
 */
@kotlin.Metadata()
@kotlin.Suppress(names = {"UNRESOLVED_REFERENCE"})
public abstract interface A {
    @org.jetbrains.annotations.NotNull()
    public static final A.Companion Companion = null;

    @org.jetbrains.annotations.NotNull()
    public abstract java.lang.String getX();

    public abstract void inject(@org.jetbrains.annotations.NotNull()
    A.B b);

    /**
     * public abstract class A.B : A {
     *
     *   // signature: <init>()V
     *   public constructor()
     *
     *   // signature: inject(LA$B;)V
     *   public open (* delegation *) fun inject(b: A.B): kotlin/Unit
     *
     *   public open (* delegation *) val x: kotlin/String
     *     public open get
     *
     *   // module name: main
     * }
     */
    @kotlin.Metadata()
    public static abstract class B implements A {

        public B() {
            super();
        }
    }

    /**
     * public final companion object A.Companion : A.B {
     *
     *   // signature: <init>()V
     *   private constructor()
     *
     *   // module name: main
     * }
     */
    @kotlin.Metadata()
    public static final class Companion extends A.B {

        private Companion() {
            super();
        }
    }
}
